// Controller X/Y/Z to single axis rotation

angle = Math.sqrt(xOri*xOri + yOri*yOri + zOri*zOri)
xA = xOri / angle
yA = yOri / angle
zA = zOri / angle

// Convert to quaternion

float d = Math.sqrt(xA*xA + yA*yA + zA*zA)

if (d == 0f) return;
d = 1f / d;

float l_ang = angle < 0 ? PI*2 - (-angle % PI*2) : angle % PI*2;
float l_sin = (float)Math.sin(l_ang / 2);
float l_cos = (float)Math.cos(l_ang / 2);

qX = d * xA * l_sin
qY = d * yA * l_sin
qZ = d * zA * l_sin
qW = l_cos

// Get Euler angles back

public int getGimbalPole () {
	final float t = y * x + z * w;
	return t > 0.499f ? 1 : (t < -0.499f ? -1 : 0);
}

public float getRollRad () {
	final int pole = getGimbalPole();
	return pole == 0 ? atan2(2f * (w * z + y * x), 1f - 2f * (x * x + z * z)) : (float)pole * 2f
		* atan2(y, w);
}

public float getPitchRad () {
	final int pole = getGimbalPole();
	return pole == 0 ? (float)Math.asin(clamp(2f * (w * x - z * y), -1f, 1f)) : (float)pole * PI * 0.5f;
}

public float getYawRad () {
	return getGimbalPole() == 0 ? atan2(2f * (y * w + x * z), 1f - 2f * (y * y + x * x)) : 0f;
}